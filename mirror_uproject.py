#!/usr/bin/env python3
"""
mirror.py — Push or pull an Unreal (or any) project between local SSD
and a Dropbox backup, skipping heavy cache/build folders.

Example usage
-------------
# Push local → Dropbox
python mirror.py push "D:\\GameDev\\Projects\\DishonoredDead"

# Pull Dropbox → local
python mirror.py pull "D:\\GameDev\\Projects\\DishonoredDead"

# Dry-run (see what would happen)
python mirror.py push "D:\\GameDev\\Projects\\DishonoredDead" --dry-run
"""
import argparse, filecmp, os, shutil, sys, time
from pathlib import Path

# ─── Path roots ───────────────────────────────────────────────────────
DROPBOX_ROOT = Path(r"D:\DropBox")                 # Your Dropbox root
BACKUP_BASE  = DROPBOX_ROOT / "Projects"            # Backup projects sit here

# Folders to skip entirely (regenerated by Unreal / build tools)
EXCLUDE_DIRS = {
    "DerivedDataCache",
    "Intermediate",
    os.path.join("Saved", "Cooked"),
    "Binaries",
}

# ─── Helpers ──────────────────────────────────────────────────────────
def should_skip(rel_path: Path) -> bool:
    """Return True if any component of rel_path matches EXCLUDE_DIRS."""
    return any(part in EXCLUDE_DIRS for part in rel_path.parts)

def mirror(src: Path, dst: Path, dry: bool, allow_delete: bool):
    """Recursively mirror src → dst, respecting dry-run and delete flag."""
    rel = src.relative_to(source_root)
    if should_skip(rel):
        return

    if src.is_dir():
        if not dry:
            dst.mkdir(parents=True, exist_ok=True)

        # Handle deletions
        if allow_delete and dst.exists():
            dst_items = {p.name for p in dst.iterdir()}
            src_items = {p.name for p in src.iterdir()}
            for orphan in dst_items - src_items:
                orphan_path = dst / orphan
                print(f"DEL {orphan_path}")
                if not dry:
                    if orphan_path.is_dir():
                        shutil.rmtree(orphan_path, ignore_errors=True)
                    else:
                        orphan_path.unlink(missing_ok=True)

        # Recurse
        for child in src.iterdir():
            mirror(child, dst / child.name, dry, allow_delete)

    else:  # file
        needs_copy = (not dst.exists() or
                      not filecmp.cmp(src, dst, shallow=False))
        if needs_copy:
            print(f"COPY {src}  ->  {dst}")
            if not dry:
                dst.parent.mkdir(parents=True, exist_ok=True)
                shutil.copy2(src, dst)

# ─── CLI ──────────────────────────────────────────────────────────────
def parse_args():
    p = argparse.ArgumentParser(
        description="Mirror UE project between local SSD and Dropbox backup")
    p.add_argument("direction", choices=("push", "pull"),
                   help="push = local→Dropbox   pull = Dropbox→local")
    p.add_argument("local_project",
                   help="Local project folder, e.g. D:\\GameDev\\Projects\\DishonoredDead")
    p.add_argument("--dry-run", action="store_true",
                   help="Preview actions without copying / deleting files")
    p.add_argument("--force-delete", action="store_true",
                   help="Actually delete orphans in destination (safe-guard off)")
    return p.parse_args()

# ─── Main ─────────────────────────────────────────────────────────────
if __name__ == "__main__":
    args = parse_args()

    local_root  = Path(args.local_project).resolve()

    # Backup path: D:\DropBox\Projects\<ProjectName>
    backup_root = BACKUP_BASE / local_root.name

    if args.direction == "push":
        source_root, dest_root = local_root, backup_root
        banner = "PUSH  local → Dropbox"
    else:
        source_root, dest_root = backup_root, local_root
        banner = "PULL  Dropbox → local"

    if not source_root.exists():
        sys.exit(f"❌ Source folder does not exist:\n   {source_root}")

    print(f"🔄 {banner}\n    src: {source_root}\n    dst: {dest_root}")
    if args.dry_run:
        print("⚠️  DRY-RUN mode — no files will be modified")

    t0 = time.time()
    mirror(source_root, dest_root, dry=args.dry_run,
           allow_delete=args.force_delete)
    print(f"✅ Completed in {time.time()-t0:.1f}s")
