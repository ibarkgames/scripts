#!/usr/bin/env python3
"""
mirror_backup.py
Incremental mirror of an Unreal project into Dropbox (or any target dir).

Usage (default destination):
    python mirror_backup.py "D:\Projects\DishonoredDead"

Usage (explicit destination):
    python mirror_backup.py "D:\Projects\DishonoredDead" "E:\Backups\DD_cloud"

The script:
  • copies only changed / new files
  • deletes files that disappeared from the source
  • skips heavy cache/build folders to save space & bandwidth
"""

import argparse, filecmp, os, shutil, sys, time
from pathlib import Path

# Folders we never copy (regenerated by Unreal)
EXCLUDE_DIRS = {
    "DerivedDataCache",
    "Intermediate",
    os.path.join("Saved", "Cooked"),
    "Binaries",
}

def should_skip(rel_path: Path) -> bool:
    """Return True if any part of rel_path is in EXCLUDE_DIRS."""
    parts = set(Path(*rel_path.parts).parts)  # normalize slashes
    return any(x in parts for x in EXCLUDE_DIRS)

def mirror(src: Path, dst: Path):
    """Recursively mirror src → dst, honoring EXCLUDE_DIRS."""
    rel = src.relative_to(source_root)
    if should_skip(rel):
        return

    if src.is_dir():
        dst.mkdir(parents=True, exist_ok=True)

        # Remove items that were deleted at the source
        dst_items = {p.name for p in dst.iterdir()} if dst.exists() else set()
        src_items = {p.name for p in src.iterdir()}
        for orphan in dst_items - src_items:
            orphan_path = dst / orphan
            if orphan_path.is_dir():
              shutil.rmtree(orphan_path, ignore_errors=True)
            else:
              orphan_path.unlink(missing_ok=True) 

        # Recurse
        for child in src.iterdir():
            mirror(child, dst / child.name)

    else:  # file
        if not dst.exists() or not filecmp.cmp(src, dst, shallow=False):
            shutil.copy2(src, dst)

def parse_args():
    h = "Mirror an Unreal project to Dropbox, skipping build caches"
    p = argparse.ArgumentParser(description=h)
    p.add_argument("source", help="Path to local project root (e.g. D:\\GameDev\\Projects\\DishonoredDead)")
    p.add_argument(
        "dest",
        nargs="?",
        help="Mirror destination D:\\Dropbox\\GameDev\\Projects\\<project>)",
    )
    return p.parse_args()

if __name__ == "__main__":
    args = parse_args()

    source_root = Path(args.source).expanduser().resolve()
    if not source_root.exists():
        sys.exit(f"❌ Source folder does not exist: {source_root}")

    # Default destination → Dropbox\GameDev\Projects\<ProjectName>
    # Path.home()
    if args.dest:
        dest_root = Path(args.dest).expanduser().resolve()
    else:
        
        default_base =  Path(r"D:\DropBox") / "Dropbox" / "GameDev" / "Projects"
        dest_root = default_base / source_root.name

    t0 = time.time()
    mirror(source_root, dest_root)
    elapsed = time.time() - t0
    print(f"✅ Mirror complete → {dest_root}\n   Time: {elapsed:.1f}s")
